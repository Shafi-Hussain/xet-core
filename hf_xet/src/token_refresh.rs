use std::fmt::{Debug, Formatter};

use pyo3::exceptions::PyTypeError;
use pyo3::prelude::PyAnyMethods;
use pyo3::{Py, PyAny, PyErr, PyResult, Python};
use tracing::{error, info};
use utils::auth::{TokenInfo, TokenRefresher};
use utils::errors::AuthError;

use std::sync::atomic::Ordering;
use std::sync::atomic::AtomicU64;
use std::time::Instant;
use paste::paste;

/// A wrapper struct of a python function to refresh the CAS auth token.
/// Since tokens are generated by hub, we want to be able to refresh the
/// token using the hub client, which is only available in python.
pub struct WrappedTokenRefresher {
    /// The function responsible for refreshing a token.
    /// Expects no inputs and returns a (str, u64) representing the new token
    /// and the unixtime (in seconds) of expiration, raising an exception
    /// if there is an issue.
    py_func: Py<PyAny>,
    name: String,
}

impl Debug for WrappedTokenRefresher {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "WrappedTokenRefresher({})", self.name)
    }
}

impl WrappedTokenRefresher {
    pub fn from_func(py_func: Py<PyAny>) -> PyResult<Self> {
        let name = Self::validate_callable(&py_func)?;
        Ok(Self { py_func, name })
    }

    /// Validate that the inputted python object is callable
    fn validate_callable(py_func: &Py<PyAny>) -> Result<String, PyErr> {
        Python::with_gil(|py| {
            let f = py_func.bind(py);
            let name = f
                .repr()
                .and_then(|repr| repr.extract::<String>())
                .unwrap_or("unknown".to_string());
            if !f.is_callable() {
                error!("TokenRefresher func: {name} is not callable");
                return Err(PyTypeError::new_err(format!("refresh func: {name} is not callable")));
            }
            Ok(name)
        })
    }
}

#[macro_export]
macro_rules! create_metrics {
    ($prefix:literal) => {
        paste::paste! {
            static [<$prefix _CALL_COUNT>]: AtomicU64 = AtomicU64::new(0);
            static [<$prefix _TOTAL_TIME>]: AtomicU64 = AtomicU64::new(0);
            static [<$prefix _MAX_TIME>]: AtomicU64 = AtomicU64::new(0);
        }
    };
}

create_metrics!("TOKEN_REFRESH");

#[macro_export]
macro_rules! print_metrics {
    ($prefix:literal) => {
        paste::paste! {

            // Load the values from the corresponding atomic variables
            let call_count = [<$prefix _CALL_COUNT>].load(Ordering::Relaxed);
            let total_time = [<$prefix _TOTAL_TIME>].load(Ordering::Relaxed) as f64;
            let max_time = [<$prefix _MAX_TIME>].load(Ordering::Relaxed) as f64;

            if call_count > 0 {
                let avg_time = total_time / (call_count as f64);
                let (div, unit) = if avg_time > 1_000_000_000.0 {
                    (1_000_000_000, "")
                } else if avg_time > 1_000_000.0 {
                    (1_000_000, "m")
                } else if avg_time > 1_000.0 {
                    (1_000, "u")
                } else {
                    (1, "n")
                };
                let div = div as f64;
                println!(
                    "{} Metrics:\n- Max Time: {:.2} {}s\n- Average Time: {:.2} {}s\n- Number of Calls: {}",
                    $prefix, max_time / div, unit, avg_time / div, unit, call_count
                );
            } else {
                println!("{} Metrics:\n- No calls recorded yet.", $prefix);
            }

        }
    };
}

#[macro_export]
macro_rules! track_metrics {
    ($prefix:literal, $closure:expr) => {
        // paste! {
        {
            let start = Instant::now();
            // Call the closure and capture its result
            let result = $closure();

            let elapsed = start.elapsed().as_nanos() as u64;

            // Update the metrics
            // paste! {
            paste! {[<$prefix _CALL_COUNT>]}.fetch_add(1, Ordering::Relaxed);

            paste! {[<$prefix _TOTAL_TIME>]}.fetch_add(elapsed, Ordering::Relaxed);

            paste! {[<$prefix _MAX_TIME>]}
                .fetch_update(Ordering::Relaxed, Ordering::Relaxed, |max_time| {
                    if elapsed > max_time {
                        Some(elapsed)
                    } else {
                        None
                    }
                })
                .ok(); // Ignore the result of fetch_update
                       // }
                       // Return the result of the closure
            result
        }
    };
}

impl TokenRefresher for WrappedTokenRefresher {
    fn refresh(&self) -> Result<TokenInfo, AuthError> {
        info!("refreshing token");
        let clo = || Python::with_gil(|py| {
            let f = self.py_func.bind(py);
            if !f.is_callable() {
                return Err(AuthError::RefreshFunctionNotCallable(self.name.clone()));
            }
            let result = f
                .call0()
                .map_err(|e| AuthError::TokenRefreshFailure(format!("Error refreshing token: {e:?}")))?;
            result.extract::<(String, u64)>().map_err(|e| {
                AuthError::TokenRefreshFailure(format!("refresh function didn't return a (String, u64) tuple: {e:?}"))
            })
        });
        track_metrics!("TOKEN_REFRESH", clo)
    }
}

impl Drop for WrappedTokenRefresher {
    fn drop(&mut self) {
        print_metrics!("TOKEN_REFRESH");
    }
}
